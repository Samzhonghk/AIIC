<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Repay Schedule</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background:#f8f9fa; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    .container { max-width:900px; margin:40px auto; }
    .card { padding:20px; border-radius:8px; }
    .table th, .table td { vertical-align:middle; }
    .remain-box { text-align: right; margin-bottom: 8px; }
    .remain-amount { font-size: 1.1rem; font-weight: 600; color: #c0392b; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h3>Payment for existing customer</h3>
      <p id="info" class="text-muted"></p>
      <p id="info_clientName" class="text-muted"></p>
      <!-- <p>
        <strong id="info" class="text-muted"></strong>
        <strong id="info_clientName" class="text-muted"></strong>
      </p> -->
      
      <div id="content">Loading...</div>
      <a id="backBtn" class="btn btn-secondary mt-3">Back</a>
    </div>
  </div>
  <script>
    function getQueryParam(name){ const u = new URL(window.location.href); return u.searchParams.get(name); }
    const clientNumber = getQueryParam('clientNumber');
    // const clientName = getQueryParam('clientName');
    document.getElementById('backBtn').addEventListener('click', ()=> window.history.back());
    if(!clientNumber){ document.getElementById('content').innerHTML = '<p class="text-danger">Missing clientNumber</p>'; }
    else{
      document.getElementById('info').textContent = 'Client Number: ' + clientNumber;
      // 请求客户信息并显示客户姓名（若有）
      fetch('/api/clients/' + encodeURIComponent(clientNumber)).then(r => {
        if (!r.ok) throw new Error('no client');
        return r.json();
      }).then(cdata => {
        try {
          const name = cdata && cdata.client ? (cdata.client.name || cdata.client.client_name || '') : (cdata && cdata.name ? cdata.name : '');
          if (name) document.getElementById('info_clientName').textContent = 'Client Name: ' + name;
        } catch (e) { /* ignore */ }
      }).catch(() => {
        // ignore failures
      });
      function renderRepayData(data){
        if(!Array.isArray(data) || data.length===0){ document.getElementById('content').innerHTML = '<p class="text-warning">No repay records found.</p>'; return; }
    // Note: per-row late fee column removed; user will enter a custom late fee below when recording a payment
        const now = Math.floor(Date.now()/1000);
  let rowsHTML = '';
  let totalPaid = 0;
  let totalRemainingPrincipal = 0;
        for(const it of data){
          const repayId = it.repay_id || '';
          const loanId = it.loan_id || it.loan_number || '';
          const repayDate = it.repay_date || 0;
          const dueDate = Number(it.due_date) || 0;
          const repayAmount = (it.repay_amount!=null? Number(it.repay_amount) : (it.repayAmount!=null? Number(it.repayAmount) : 0)) || 0;
          const paidAmount = it.paid_amount != null ? Number(it.paid_amount) : 0;
          totalPaid += paidAmount;
          // note: stored late fee (it.late_fee) may exist but UI no longer shows per-row late fee
          // remaining principal for this row
          const remainingThis = Math.max(repayAmount - paidAmount, 0);
          totalRemainingPrincipal += remainingThis;
          // already-paid late fee for this repay row (backend may return aggregated value as `late_fee`)
          const paidLateFee = it.late_fee != null ? Number(it.late_fee) : 0;
          // determine if this row should be selectable: disable if already fully paid
          const isPaid = (it.status === 'paid') || (paidAmount >= repayAmount && repayAmount > 0);
          const radioDisabledAttr = isPaid ? 'disabled' : '';
          const rowClass = isPaid ? 'table-secondary text-muted' : '';
          // show paid_date (the actual date payment was made) only when payment exists
          const paidDate = Number(it.paid_date) || 0;
          rowsHTML += `<tr class="${rowClass}" data-repay-id="${repayId}" data-loan-id="${loanId}" data-client-id="${it.client_id || ''}" data-due-date="${dueDate}" data-repay-amount="${repayAmount.toFixed(2)}" data-remaining="${remainingThis.toFixed(2)}" data-late-fee="${paidLateFee.toFixed(2)}">
            <td><input type="radio" name="selectedRepay" value="${repayId}" ${radioDisabledAttr}></td>
            <td>${repayId}</td>
            <td>${loanId}</td>
            <td>${paidDate? new Date(paidDate*1000).toLocaleDateString() : ''}</td>
            <td>${dueDate? new Date(dueDate*1000).toLocaleDateString() : ''}</td>
            <td>${repayAmount.toFixed(2)}</td>
            <td>${paidAmount.toFixed(2)}</td>
            <td>${paidLateFee.toFixed(2)}</td>
            <td>${it.status || ''}</td>
          </tr>`;
        }

        document.getElementById('content').innerHTML = `
          <div class="remain-box">
            <div class="remain-amount">Remaining: ${totalRemainingPrincipal.toFixed(2)}</div>
          </div>
          <table class="table table-striped">
            <thead><tr><th></th><th>Repay ID</th><th>Loan</th><th>Repay Date</th><th>Due Date</th><th>Amount</th><th>Paid</th><th>Late Fee Paid</th><th>Status</th></tr></thead>
            <tbody>${rowsHTML}</tbody>
          </table>
            <div class="mt-2 mb-3">
            <strong>Total Already Paid:</strong> <span id="totalPaid">${totalPaid.toFixed(2)}</span>
          </div>
            <div class="mt-3">
            <label for="recordAmount">Repay Amount :</label>
            <input id="recordAmount" class="form-control mb-2" type="number" step="0.01" min="0.01" placeholder="Enter amount to repay">
            <div id="recordMinMsg" class="form-text text-muted mb-2"></div>
            <label for="recordLateFee" class="form-label mt-2">Late Fee (optional):</label>
            <input id="recordLateFee" class="form-control mb-2" type="number" step="0.01" min="0" placeholder="Enter late fee amount">
            <label for="recordRemark">Remark (optional):</label>
            <input id="recordRemark" class="form-control mb-2" type="text" placeholder="Remark">
            <button id="recordBtn" class="btn btn-success">Repay</button>
            <div id="recordMsg" class="mt-2"></div>
          </div>
        `;

        // no per-row late fee overrides; user provides late fee in the payment form below

        // when a repayment row is selected, update the recordAmount min and show hint
        function onRepayRowSelected(e){
          const sel = e.target;
          const tr = sel.closest('tr');
          const scheduled = parseFloat(tr.getAttribute('data-repay-amount')) || 0;
          const remaining = parseFloat(tr.getAttribute('data-remaining')) || 0;
          const recordAmountEl = document.getElementById('recordAmount');
          // store the scheduled min in dataset; do NOT set max attribute or remaining dataset to avoid client-side blocking
          recordAmountEl.dataset.scheduledMin = String(scheduled);
          recordAmountEl.min = scheduled.toFixed(2);
          const hint = document.getElementById('recordMinMsg');
        //   if(hint) hint.textContent = 'At least：NZ$' + scheduled.toFixed(2) + (remaining>0 ? ('，remaining：NZ$' + remaining.toFixed(2)) : '');
          if(hint) hint.textContent = 'At least：' + scheduled.toFixed(2) ;
        }
        document.querySelectorAll('input[name="selectedRepay"]').forEach(r=> r.addEventListener('change', onRepayRowSelected));

        // submission handler moved into a reusable function
        async function handleRecordClick(){
          const sel = document.querySelector('input[name="selectedRepay"]:checked');
          const msg = document.getElementById('recordMsg');
          msg.textContent = '';
          if(!sel){ msg.innerHTML = '<span class="text-danger">Please select a repayment period first.</span>'; return; }
          const repayId = sel.value;
          const tr = sel.closest('tr');
          const loanId = tr.getAttribute('data-loan-id');
          const clientId = tr.getAttribute('data-client-id');
          const dueDate = Number(tr.getAttribute('data-due-date')) || Math.floor(Date.now()/1000);
          const amount = parseFloat(document.getElementById('recordAmount').value);
          const remark = document.getElementById('recordRemark').value || null;
          if(!amount || amount <= 0){ msg.innerHTML = '<span class="text-danger">无效金额</span>'; return; }
          // enforce scheduled minimum (read from recordAmount.dataset which is set when selecting a row)
          const recordAmountEl = document.getElementById('recordAmount');
          // remove client-side max constraint at submit time so backend will be the final authority
          try { recordAmountEl.setCustomValidity(''); } catch(e) { /* ignore */ }
          try { recordAmountEl.removeAttribute('max'); } catch(e) { /* ignore */ }
          const scheduledMin = parseFloat(recordAmountEl.dataset.scheduledMin || '0') || 0;
          if(scheduledMin > 0 && amount < scheduledMin){ msg.innerHTML = '<span class="text-danger">Amount can not be less than ' + scheduledMin.toFixed(2) + '</span>'; return; }

          // read custom late fee from the payment form
          const lateFeeValue = parseFloat(document.getElementById('recordLateFee').value) || 0;
          const lateFeeOverride = true; // user-specified late fee should be treated as override

          const payload = {
            repay_id: repayId,
            loan_id: loanId,
            client_id: clientId,
            amount: amount,
            paid_date: Math.floor(Date.now()/1000),
            remark: remark,
            late_fee: lateFeeValue,
            late_fee_override: lateFeeOverride
          };
          try{

            const r = await fetch('/api/repay-records/payments', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
            if(!r.ok){
              let errBody;
              try { errBody = await r.json(); } catch(e) { errBody = { error: await r.text() }; }
              const remaining = errBody && (errBody.remaining != null ? errBody.remaining : (errBody.remaining_amount || errBody.remainingAmount || null));
              const em = errBody && (errBody.error || errBody.message) ? (errBody.error || errBody.message) : JSON.stringify(errBody);
              if (remaining != null) {
                msg.innerHTML = '<span class="text-danger">Payment failed: repay amount is more than remaining ' + Number(remaining).toFixed(2) + '</span>';
                return;
              }
              throw new Error(em || 'Failed');
            }
            const j = await r.json();
            // msg.innerHTML = '<span class="text-success">Recorded payment id: '+ (j.payment_id || j.paymentId || '') +'</span>';
            msg.innerHTML = '<span class="text-success">Repay successfully.</span>';
            // if server returned updated repay row, update the specific table row to avoid full reload
            if (j.repay) {
              const tr = document.querySelector(`tr[data-repay-id="${j.repay.repay_id}"]`);
              if (tr) {
                const tds = tr.querySelectorAll('td');
                // columns: 0=radio,1=repayId,2=loan,3=Repay Date,4=Due Date,5=Amount,6=Paid,7=Late Fee Paid,8=Status
                tds[3].textContent = j.repay.paid_date ? new Date(j.repay.paid_date*1000).toLocaleDateString() : '';
                tds[6].textContent = Number(j.repay.paid_amount || 0).toFixed(2);
                tr.setAttribute('data-remaining', (Number(j.repay.repay_amount || 0) - Number(j.repay.paid_amount || 0)).toFixed(2));
                tds[7].textContent = Number(j.repay.late_fee || 0).toFixed(2);
                tds[8].textContent = j.repay.status || '';

                // Update row classes and radio state to reflect paid/unpaid immediately
                const paidAmountNum = Number(j.repay.paid_amount || 0);
                const repayAmountNum = Number(j.repay.repay_amount || 0);
                const lateFeeNum = Number(j.repay.late_fee || 0);
                const statusNow = j.repay.status || '';
                const isPaidNow = (statusNow === 'paid') || (repayAmountNum > 0 && paidAmountNum >= repayAmountNum);
                if (isPaidNow) {
                  tr.classList.add('table-secondary', 'text-muted');
                } else {
                  tr.classList.remove('table-secondary', 'text-muted');
                }
                // Update radio disabled state correctly and uncheck it
                const radio = tr.querySelector('input[name="selectedRepay"]');
                if (radio) {
                  radio.disabled = isPaidNow;
                  radio.checked = false;
                }
                // Fix selector: use :not(:disabled) to find next selectable radio
                const next = document.querySelector('input[name="selectedRepay"]:not(:disabled)');
                if (next) {
                  next.checked = true;
                  next.dispatchEvent(new Event('change', { bubbles: true }));
                }

                // OPTIONAL: update top-level totals without full reload by recomputing from DOM
                try {
                  let totalPaid = 0;
                  document.querySelectorAll('table tbody tr').forEach(r => {
                    const paidCell = r.children[6];
                    if (paidCell) {
                      const v = parseFloat((paidCell.textContent || '').replace(/[^0-9.-]/g, '')) || 0;
                      totalPaid += v;
                    }
                  });
                  const totalPaidEl = document.getElementById('totalPaid');
                  if (totalPaidEl) totalPaidEl.textContent = totalPaid.toFixed(2);

                  let totalRemaining = 0;
                  document.querySelectorAll('table tbody tr').forEach(r => {
                    const rem = parseFloat(r.getAttribute('data-remaining')) || 0;
                    totalRemaining += rem;
                  });
                  const remainEl = document.querySelector('.remain-amount');
                  if (remainEl) remainEl.textContent = 'Remaining: ' + totalRemaining.toFixed(2);
                } catch (e) { /* non-fatal, ignore */ }
              } else {
                // fallback: re-fetch full list
                const fresh = await fetch('/api/repay-records/?clientNumber=' + encodeURIComponent(clientNumber)).then(r=>r.json());
                renderRepayData(fresh);
              }
            } else {
              // refresh data by re-fetching repay records
              const fresh = await fetch('/api/repay-records/?clientNumber=' + encodeURIComponent(clientNumber)).then(r=>r.json());
              renderRepayData(fresh);
            }
          }catch(err){ msg.innerHTML = '<span class="text-danger">Error: '+ err.message +'</span>'; }
        }

        // attach handler for record button
        document.getElementById('recordBtn').addEventListener('click', async function(){ await handleRecordClick(); });
      }

      // initial fetch and render
      fetch('/api/repay-records/?clientNumber=' + encodeURIComponent(clientNumber)).then(r=>r.json()).then(data=>{
        renderRepayData(data);
      }).catch(err=>{ document.getElementById('content').innerHTML = '<p class="text-danger">Error: '+err.message+'</p>'; });
    }
  </script>
</body>
</html>